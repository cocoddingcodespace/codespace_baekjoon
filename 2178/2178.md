# 백준 2178 - 메모이제이션 BFS 오답 원인 분석

## ✅ 문제 요약
- 미로에서 `(0, 0)`부터 `(n-1, m-1)`까지 이동할 때 **최소 칸 수**를 출력하는 문제
- `1`은 이동 가능, `0`은 벽
- BFS를 사용하면 최단 경로가 보장됨

---

## ✅ 오답 코드 핵심 문제

### ❌ 1. `memset()` 오용

```cpp
memset(cache, n * m, sizeof(cache));
```

- `memset()`은 **바이트 단위 초기화**
- `n * m`이 예를 들어 `100`이면, `0x64`를 모든 바이트에 채움
- `int[101][101]` 배열에는 **의도와 다른 쓰레기 값이 들어감**

#### ✅ 수정 방법
```cpp
const int INF = 1e9;
for (int i = 0; i < 101; i++)
    for (int j = 0; j < 101; j++)
        cache[i][j] = INF;
```

또는 C++11 이상에서는:
```cpp
fill(&cache[0][0], &cache[0][0] + 101 * 101, INF);
```

---

### ❌ 2. 종료 조건 잘못됨

```cpp
if (cur.y == n && cur.x == m) break;
```

- 인덱스는 0부터 시작하므로 잘못된 비교

#### ✅ 수정
```cpp
if (cur.y == n - 1 && cur.x == m - 1) break;
```

---

## ✅ 메모이제이션 BFS에서 중요한 조건

```cpp
if (cache[ny][nx] <= cur.depth + 1) continue;
```

- 이미 더 짧게 방문한 곳은 다시 방문하지 않음
- 새로 방문한 길이 더 짧을 때만 갱신

---

## ✅ 요약

| 항목 | 설명 |
|------|------|
| BFS 사용 이유 | 최단 거리 보장 |
| 오답 원인 ① | `memset()` 오용으로 초기화 실패 |
| 오답 원인 ② | 종료 조건 인덱스 오류 |
| 해결 방법 | `for` 루프 또는 `fill()`로 큰 값 초기화 + 종료 조건 수정 |
| 메모이제이션 사용 시 핵심 | 항상 더 짧은 거리일 때만 갱신 |

---

## 🧠 추가 팁

### `memset()`은 아래의 경우에만 안전하게 사용:
- `memset(arr, 0, sizeof(arr))` → OK
- `memset(arr, -1, sizeof(arr))` → 대부분 OK (`-1`로 채워짐)
- ✅ 그 외 숫자는 `절대 사용하지 말 것`!
